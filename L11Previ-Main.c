/* Main.c file generated by New Project wizard
 *
 * Created:   ma. nov. 15 2016
 * Processor: PIC18F4550
 * Compiler:  MPLAB XC8
   SENSOR 13!
 */
 
#include <xc.h>
#include <stdio.h>
#include "config.h"
#include "GLCD.h"
#include <string.h>
#include <stdlib.h>
#define POTENCIOMETRE 1
#define SHARP 2
#define TOT 3
#define IDLE 4

long mesura;
unsigned int mesura_distancia;
float mesura_voltatge;
int canvi_estat = 0;
int sensor = IDLE;
int pote=1;

void interrupt high_priority timer(){
 if (TMR0IE && TMR0IF) {
 TMR0IF = 0;
 TMR0 = 0xEC78;
 sensor=TOT;
 pote=-pote;
 }
}

void INIT_PACKET (char *pack){
   sprintf(pack,"INIT\n");
}
void DATA_PACKET (float angle, float dist,char *pack){
   //int valor_a=angle;
   // int valor_d=dist;
   sprintf(pack,"DATA,%.02f,%.02f\n",angle,dist);//valor_a,valor_d);
}

void SEND_PACKET (char *pack, int size){
   int i;
   for (i = 0; i < size; ++i) {
      while (!TXIF);
      TXREG = pack[i];
   }  
}

void configPIC(){
 TRISA = 0x03;
 CHS3 = 0;
 CHS2 = 0;
 CHS1 = 0;
 CHS0 = 0;
 ADON = 1;
 GO = 1;
 VCFG1 = 0;
 VCFG0 = 0;
 PCFG3 = 1;
 PCFG2 = 1;
 PCFG1 = 0;
 PCFG0 = 1;
 ADFM = 1;
 ACQT2 = 0;
 ACQT1 = 0;
 ACQT0 = 1;
 ADCS2 = 0;
 ADCS1 = 0;
 ADCS0 = 1;
 
}
void configTimer0(){
 //configureu el timer0 per obtenir una interrupció
 //cada període de mostreig de la freq més alta
   IPEN = 1;
   GIEH = 1;
   TMR0ON = 1;
   T08BIT = 0;//a 16
   T0CS = 0;
   T0SE = 1;
   PSA = 0; 
   T0PS2 = 0;//prescaler
   T0PS1 = 0;
   T0PS0 = 0;
   TMR0IE = 1;
   TMR0IP = 1;
   TMR0IF = 0;
   
}
void configUSART(){
      //Config Trisa
   TRISCbits.RC6 = 0;
   TRISCbits.RC7 = 1; 
   //Configuracio TXSTA
   //TXSTAbits.TX9=0;
   TXSTAbits.TXEN=1;
   TXSTAbits.SYNC=0;
   TXSTAbits.BRGH = 1;
   //Config RCSTA   
   RCSTAbits.SPEN=1;
   //RCSTAbits.RX9=0;
   RCSTAbits.CREN=1;
   //Config BAUDCON
   //BAUDCONbits.RXDTP=0;
   //BAUDCONbits.TXCKP=0;
   BAUDCONbits.BRG16=1;
   SPBRG=34;
   //
}


void main (void) {
   configPIC(); //inicialitzem el pic
   configTimer0(); //configurem tmr0
   configUSART(); //configurem usart
   GLCDinit(); //inicialitzem glcd
   clearGLCD(0, 7, 0, 127);
   setStartLine(0);
   //Paquet
   char pack[256];
   INIT_PACKET(pack);
   SEND_PACKET(pack,strlen(pack));
   char buf[50];
   TMR0 = 0xEC78;
   //Comprovacio actualitzat
   float angle_old=0;
   float dist_old=0;
   while(1) {
      switch (sensor) {
	 /* case POTENCIOMETRE:
	 //llegim el valor del potenciometre
	    CHS0 = 0;
	    GO = 1;
	    mesura_distancia = ADRES;
	    mesura_voltatge = mesura_distancia * 0.00488;
	    sprintf(buf,"Voltatge: %f",mesura_voltatge);
	    writeTxt(1, 0, buf);
	      sensor = IDLE;
	    break;*/
	    /*case SHARP:
	    //llegim el valor del sensor sharp
	       CHS0 = 1;
	    while(GO == 1);
	    mesura_distancia = ADRES;
	    GO = 1;
	    mesura_voltatge = mesura_distancia *0.004887;
	    sprintf(buf,"Voltatge: %f\n",mesura_voltatge);
	    writeTxt(3, 0, buf);
	       sensor = IDLE;
	       break;*/
	    
	    
      case TOT: //Potenciometre i Sharp
	 CHS0 = 0;
	 while(GO == 1);
	 mesura_distancia = ADRES;
	 mesura_voltatge = mesura_distancia *0.004887 ;
	 GO = 1;
	 float vol2=mesura_voltatge*mesura_voltatge;
	 float vol3=mesura_voltatge*mesura_voltatge*mesura_voltatge;
	 float valor_d= (-43.205*mesura_voltatge) + (38.5512) + (19.7525*vol2) - (3.1621*vol3);
	 sprintf(buf,"Distancia: %.02f",valor_d);
	 writeTxt(1, 0, buf);
	 CHS0 = 1;
	 float valor_a;
	 //Cas potenciometre 1 de cada 2 cops
	 if(pote>0){ 
	    while(GO == 1);
	    mesura_distancia = ADRES;
	    GO = 1;
      	    mesura_voltatge = mesura_distancia * 0.004887;
	    valor_a=50.7498440104970*mesura_voltatge-38.75622016392627;
	    sprintf(buf,"Angle: %.02f\n",valor_a);
	    writeTxt(3, 0, buf);
	 }
	 if(valor_a!=angle_old || valor_d != dist_old){
	    DATA_PACKET(valor_a, valor_d,pack);
	    SEND_PACKET(pack,strlen(pack));
	    angle_old=valor_a;
	    dist_old=valor_d;
	 }
	 
	 sensor = IDLE;
	 break;
	 
      case IDLE:	//no cal llegir cap sensor
	 break;
      }
   }
}
